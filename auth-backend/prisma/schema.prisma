generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "debian-openssl-1.1.x"]
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

//
// ENUMS
//

enum Type {
  INTERNAL
  EXTERNAL
}

enum Role {
  ADMIN
  USER
  SUPERADMIN
}

// Which login methods this client (website) allows
enum AuthMode {
  IITD_ONLY
  PASSWORD_ONLY
  BOTH
}

//
// MODELS
//

model User {
  // For IITD users
  id          String       @id @default(auto()) @map("_id") @db.ObjectId
  email       String       @unique
  name        String?
  iitduuid    String?      
  department  String?
  category    String?
  kerbrosId   String?      

  password    String?
  role        Role[]       @default([USER])
  isActive    Boolean      @default(true)
  type        Type         @default(EXTERNAL)

  // Optional Fields
  mobile      String?
  Gender      String?
  dob         DateTime?
  address     String?
  profilePic  String?

  // OnBoarding
  isOnboarded Boolean      @default(false)

  // Relations (logical, Prisma-side; Mongo doesn’t enforce FKs)
  sessions     Session[]
  clientRoles  ClientRole[]

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

model client {
  id           String       @id @default(auto()) @map("_id") @db.ObjectId
  name         String
  clientId     String       @unique
  clientSecret String       @unique
  redirectUris String[]

  // NEW: which login methods are allowed for this website
  authMode     AuthMode     @default(BOTH)

  // Relations
  clientRoles  ClientRole[]

  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
}

model AuthCode {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  code      String   @unique
  userId    String   @db.ObjectId
  clientId  String
  expiresAt DateTime
  used      Boolean  @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}


// Mapping user ↔ client ↔ roles (per-website roles)
model ClientRole {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId

  userId    String   @db.ObjectId
  clientId  String   @db.ObjectId

  user      User     @relation(fields: [userId], references: [id])
  client    client   @relation(fields: [clientId], references: [id])

  // e.g. "STUDENT", "MENTOR", "ADMIN", "COUNSELLOR", "EDITOR", ...
  role      String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Refresh-token based sessions for SSO
model Session {
  id               String   @id @default(auto()) @map("_id") @db.ObjectId

  userId           String   @db.ObjectId
  user             User     @relation(fields: [userId], references: [id])

  refreshTokenHash String   // store hashed refresh token
  userAgent        String?
  ip               String?
  expiresAt        DateTime

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model signUpOTPs {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  email     String  @unique
  otp       String
  expiresAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model passwordResetOTPs {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  email     String  @unique
  otp       String
  expiresAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
